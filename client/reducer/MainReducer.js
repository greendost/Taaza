import statusEnum from '../models/enums';
import UserFeedModel from '../models/UserFeedModel';
import FeedModel from '../models/FeedModel';

/**
 * @module client/reducer/mainReducer
 * @description Main Reducer for Taaza, following reducer + context pattern for
 * global state
 * @param {object} state
 * @param {object} action object consisting of type and payload
 * @return {object} new state object containing updates generated by action
 */
const mainReducer = (state, action) => {
  var actionArray = action;
  if (!Array.isArray(action)) {
    actionArray = [actionArray];
  }
  var newState = Object.assign({}, state);

  actionArray.forEach(action => {
    if (action.type === 'USER_STATE_UPDATE') {
      newState.userState = action.payload;
    }

    // user feeds - get all user feeds
    else if (action.type === 'USER_FEEDS_LOCAL_UPDATE') {
      newState.userFeeds = action.payload.map(uf => new UserFeedModel(uf));
    } else if (action.type === 'USER_FEEDS_REQUEST') {
      newState.userFeedsStatus = statusEnum.REQUEST;
    } else if (action.type === 'USER_FEEDS_ERROR') {
      newState.userFeedsStatus = statusEnum.ERROR;
    } else if (action.type === 'USER_FEEDS_SUCCESS') {
      newState.userFeedsStatus = statusEnum.SUCCESS;
      newState.userFeeds = action.payload.map(uf => new UserFeedModel(uf));
    } else if (action.type === 'USER_FEEDS_LOCAL_SUBSCRIBE') {
      var feed = newState.feeds.filter(f => f.feedId === action.payload)[0];
      var userFeed = new UserFeedModel(feed, {
        statusSubscribe: statusEnum.SUCCESS,
        objectType: 'feedModelObject'
      });
      // same check as user_feeds_request_subscribe, preventing duplicates
      if (!newState.userFeeds.map(uf => uf.feedId).includes(action.payload))
        newState.userFeeds.push(userFeed);
    } else if (action.type === 'USER_FEEDS_REQUEST_SUBSCRIBE') {
      var feed = newState.feeds.filter(f => f.feedId === action.payload)[0];
      var userFeed = new UserFeedModel(feed, {
        statusSubscribe: statusEnum.REQUEST,
        objectType: 'feedModelObject'
      });
      // fix for preventing duplicate feed from being added to user feeds.
      // this seems like the right place for it, as we don't want to prevent
      // the user from resubscribing in the event of error
      if (!newState.userFeeds.map(uf => uf.feedId).includes(action.payload))
        newState.userFeeds.push(userFeed);
    } else if (action.type === 'USER_FEEDS_ERROR_SUBSCRIBE') {
      let index = null;
      for (let i = 0; i < newState.userFeeds.length; i++) {
        if (newState.userFeeds[i].feedId === action.payload) {
          index = i;
          break;
        }
      }
      newState.userFeeds[index].statusSubscribe = statusEnum.ERROR;
    } else if (action.type === 'USER_FEEDS_SUCCESS_SUBSCRIBE') {
      let index = null;
      for (let i = 0; i < newState.userFeeds.length; i++) {
        if (newState.userFeeds[i].feedId === action.payload) {
          index = i;
          break;
        }
      }
      newState.userFeeds[index].statusSubscribe = statusEnum.SUCCESS;
    } else if (action.type === 'USER_FEEDS_REQUEST_UNSUBSCRIBE') {
      let index = null;
      for (let i = 0; i < newState.userFeeds.length; i++) {
        if (newState.userFeeds[i].feedId === action.payload) {
          index = i;
          break;
        }
      }
      newState.userFeeds[index].unsubscribeStatus = statusEnum.REQUEST;
    } else if (action.type === 'USER_FEEDS_ERROR_UNSUBSCRIBE') {
      let index = null;
      for (let i = 0; i < newState.userFeeds.length; i++) {
        if (newState.userFeeds[i].feedId === action.payload) {
          index = i;
          break;
        }
      }
      newState.userFeeds[index].unsubscribeStatus = statusEnum.ERROR;
    } else if (action.type === 'USER_FEEDS_SUCCESS_UNSUBSCRIBE') {
      newState.userFeeds = newState.userFeeds.filter(
        uf => uf.feedId !== action.payload
      );
    } else if (action.type === 'USER_FEEDS_LOCAL_UNSUBSCRIBE') {
      newState.userFeeds = newState.userFeeds.filter(
        uf => uf.feedId !== action.payload
      );
    } else if (action.type === 'USER_FEEDS_LOCAL_UPDATE_FAVORITE_INDEX') {
      newState.userFeeds = newState.userFeeds.map(uf => {
        if (uf.feedId === action.payload.feedId)
          return { ...uf, favoriteIndex: action.payload.favoriteIndex };
        else if (uf.favoriteIndex === action.payload.favoriteIndex)
          return { ...uf, favoriteIndex: 0 };
        else return uf;
      });

      // selected feed
    } else if (action.type === 'SELECTED_FEED_ID_LOCAL_UPDATE') {
      newState.selectedFeedId = action.payload;
    } else if (action.type === 'POSTS_FOR_SELECTED_FEED_ID_LOCAL_UPDATE') {
      newState.postsForSelectedFeedId = action.payload;
    } else if (action.type === 'POSTS_FOR_SELECTED_FEED_ID_REQUEST') {
      newState.postsForSelectedFeedId = [];
      newState.postsForSelectedFeedIdStatus = statusEnum.REQUEST;
    } else if (action.type === 'POSTS_FOR_SELECTED_FEED_ID_SUCCESS') {
      newState.postsForSelectedFeedId = action.payload;
      newState.postsForSelectedFeedIdStatus = statusEnum.REQUEST;
    } else if (action.type === 'POSTS_FOR_SELECTED_FEED_ID_ERROR') {
      newState.postsForSelectedFeedIdStatus = statusEnum.ERROR;
    } else if (action.type === 'THEME_LOCAL_UPDATE') {
      newState.settings.themeMode = action.payload;
    }

    // global or all feeds
    else if (action.type === 'GLOBAL_FEEDS_LOCAL_UPDATE') {
      newState.feeds = action.payload.map(f => new FeedModel(f));
    } else if (action.type === 'GLOBAL_FEEDS_SUCCESS') {
      newState.feeds = action.payload.map(f => new FeedModel(f));
    }
  });

  // persist state to localStorage
  try {
    localStorage.setItem('state', JSON.stringify(newState));
  } catch (err) {
    // ignore if can't do update
  }

  return newState;
};

export default mainReducer;
